// Copyright 2017 <chaishushan{AT}gmail.com>. All rights reserved.
// Use of this source code is governed by a Apache
// license that can be found in the LICENSE file.

// Package qingcloud outputs qingcloud stub code.
package qingcloud

import (
	"bytes"
	"strings"
	"text/template"

	rule_pb "github.com/chai2010/qingcloud-go/spec.pb/qingcloud_sdk_rule"
	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	"github.com/golang/protobuf/protoc-gen-go/generator"
)

// qingcloudPlugin produce the Service interface.
type qingcloudPlugin struct {
	*generator.Generator
}

// Name returns the name of the plugin.
func (p *qingcloudPlugin) Name() string { return "qingcloud" }

// Init is called once after data structures are built but before
// code generation begins.
func (p *qingcloudPlugin) Init(g *generator.Generator) {
	p.Generator = g
}

// Generate produces the code generated by the plugin for this file.
func (p *qingcloudPlugin) GenerateImports(file *generator.FileDescriptor) {
	if !p.getGenericServicesOptions(file) {
		return
	}
	if len(file.Service) > 0 {
		p.P(`import "github.com/chai2010/qingcloud-go/config"`)
		p.P(`import "github.com/chai2010/qingcloud-go/request"`)
		p.P(`import "github.com/chai2010/qingcloud-go/request/data"`)
		p.P(``)
		p.P(`var _ = config.Config{}`)
		p.P(`var _ = request.Request{}`)
		p.P(`var _ = data.Operation{}`)
	}
}

// Generate generates the Service interface.
// rpc service can't handle other proto message!!!
func (p *qingcloudPlugin) Generate(file *generator.FileDescriptor) {
	if !p.getGenericServicesOptions(file) {
		return
	}
	for _, svc := range file.Service {
		p.genServiceInterface(file, svc)
		p.genServiceServer(file, svc)
		p.genServiceClient(file, svc)
	}
}

func (p *qingcloudPlugin) getGenericServicesOptions(
	file *generator.FileDescriptor,
) bool {
	const env = "qingcloud_services"

	// try command line first
	// protoc --go_out=qingcloud_services=true:. xxx.proto
	if value, ok := p.Generator.Param[env]; ok {
		if value == "1" || strings.ToLower(value) == "true" {
			return true
		}
		if value == "0" || strings.ToLower(value) == "false" {
			return false
		}
	}

	// default is ture
	return true
}

func (p *qingcloudPlugin) genServiceInterface(
	file *generator.FileDescriptor,
	svc *descriptor.ServiceDescriptorProto,
) {
	const serviceInterfaceTmpl = `
type {{.ServiceName}}Interface interface {
	{{.CallMethodList}}
}
`
	const callMethodTmpl = `
{{.MethodName}}(in *{{.ArgsType}}) (out *{{.ReplyType}}, err error)`

	// gen call method list
	var callMethodList string
	for _, m := range svc.Method {
		out := bytes.NewBuffer([]byte{})
		t := template.Must(template.New("").Parse(callMethodTmpl))
		t.Execute(out, &struct{ ServiceName, MethodName, ArgsType, ReplyType string }{
			ServiceName: generator.CamelCase(svc.GetName()),
			MethodName:  generator.CamelCase(m.GetName()),
			ArgsType:    p.TypeName(p.ObjectNamed(m.GetInputType())),
			ReplyType:   p.TypeName(p.ObjectNamed(m.GetOutputType())),
		})
		callMethodList += out.String()

		p.RecordTypeUse(m.GetInputType())
		p.RecordTypeUse(m.GetOutputType())
	}

	// gen all interface code
	{
		out := bytes.NewBuffer([]byte{})
		t := template.Must(template.New("").Parse(serviceInterfaceTmpl))
		t.Execute(out, &struct{ ServiceName, CallMethodList string }{
			ServiceName:    generator.CamelCase(svc.GetName()),
			CallMethodList: callMethodList,
		})
		p.P(out.String())
	}
}

func (p *qingcloudPlugin) genServiceServer(
	file *generator.FileDescriptor,
	svc *descriptor.ServiceDescriptorProto,
) {
	const serviceHelperFunTmpl = `
{{/* TODO */}}
`
	{
		out := bytes.NewBuffer([]byte{})
		t := template.Must(template.New("").Parse(serviceHelperFunTmpl))
		t.Execute(out, &struct{ PackageName, ServiceName, ServiceRegisterName string }{
			PackageName:         file.GetPackage(),
			ServiceName:         generator.CamelCase(svc.GetName()),
			ServiceRegisterName: generator.CamelCase(svc.GetName()),
		})
		p.P(out.String())
	}
}

func (p *qingcloudPlugin) genServiceClient(
	file *generator.FileDescriptor,
	svc *descriptor.ServiceDescriptorProto,
) {
	const clientHelperFuncTmpl = `
type {{.ServiceName}} struct {
	Config     *config.Config
	Properties *{{.ServiceName}}Properties
}

func New{{.ServiceName}}(conf *config.Config, zone string) (p *{{.ServiceName}}) {
	return &{{.ServiceName}}{
		Config:     conf,
		Properties: &{{.ServiceName}}Properties{Zone: zone},
	}
}

func (s *QingCloudService) {{.ServiceBaseName}}(zone string) (*{{.ServiceName}}, error) {
	properties := &{{.ServiceName}}Properties{
		Zone: zone,
	}

	return &{{.ServiceName}}{Config: s.Config, Properties: properties}, nil
}

{{.MethodList}}
`
	const clientMethodTmpl = `
func (p *{{.ServiceName}}) {{.MethodName}}(in *{{.ArgsType}}) (out *{{.ReplyType}}, err error) {
	if in == nil {
		in = &{{.ArgsType}}{}
	}
	o := &data.Operation{
		Config:        p.Config,
		Properties:    p.Properties,
		APIName:       "{{.MethodName}}",
		RequestMethod: "{{.RequestMethod}}", // GET or POST
	}

	x := &{{.ReplyType}}{}
	r, err := request.New(o, in, x)
	if err != nil {
		return nil, err
	}

	err = r.Send()
	if err != nil {
		return nil, err
	}

	return x, err
}

{{if .NeedValidate}}
func (p *{{.ArgsType}}) Validate() error {
	return nil
}
{{end}}
`

	svcRule := p.getServiceExtension(svc)
	if svcRule != nil {
		if svcRule.ServiceName != "" || svcRule.SubServiceName != "" {
			// println("svc:", svcRule.ServiceName+"."+svcRule.SubServiceName)
		}
	}

	// gen client method list
	var methodList string
	for _, m := range svc.Method {
		var RequestMethod = "GET" // default is GET

		methodRule, inputRule := p.getMethodExtension(m)
		if methodRule != nil {
			if kind := methodRule.GetHttpAction(); kind != "" {
				RequestMethod = kind
			}
		}
		if inputRule != nil {
			//
		}

		out := bytes.NewBuffer([]byte{})
		t := template.Must(template.New("").Parse(clientMethodTmpl))
		t.Execute(out, &struct {
			ServiceName         string
			ServiceRegisterName string
			MethodName          string
			ArgsType            string
			ReplyType           string
			RequestMethod       string
			NeedValidate        bool
		}{
			ServiceName:         generator.CamelCase(svc.GetName()),
			ServiceRegisterName: generator.CamelCase(svc.GetName()),
			MethodName:          generator.CamelCase(m.GetName()),
			ArgsType:            p.TypeName(p.ObjectNamed(m.GetInputType())),
			ReplyType:           p.TypeName(p.ObjectNamed(m.GetOutputType())),
			RequestMethod:       RequestMethod,
			NeedValidate:        !strings.Contains(p.TypeName(p.ObjectNamed(m.GetOutputType())), "."),
		})
		methodList += out.String()
	}

	// gen all client code
	{
		out := bytes.NewBuffer([]byte{})
		t := template.Must(template.New("").Parse(clientHelperFuncTmpl))
		t.Execute(out, &struct {
			PackageName     string
			ServiceName     string
			ServiceBaseName string
			MethodList      string
		}{
			PackageName:     file.GetPackage(),
			ServiceName:     generator.CamelCase(svc.GetName()),
			ServiceBaseName: strings.TrimSuffix(generator.CamelCase(svc.GetName()), "Service"),
			MethodList:      methodList,
		})
		p.P(out.String())
	}
}

func (p *qingcloudPlugin) getServiceExtension(svc *descriptor.ServiceDescriptorProto) (svcRule *rule_pb.ServiceRule) {
	if svc.Options != nil && proto.HasExtension(svc.Options, rule_pb.E_ServiceRule) {
		if ext, _ := proto.GetExtension(svc.Options, rule_pb.E_ServiceRule); ext != nil {
			if x, _ := ext.(*rule_pb.ServiceRule); x != nil {
				svcRule = x
			}
		}
	}
	return
}

func (p *qingcloudPlugin) getMethodExtension(m *descriptor.MethodDescriptorProto) (method *rule_pb.MethodRule, input *rule_pb.MethodInputRule) {
	if m.Options != nil && proto.HasExtension(m.Options, rule_pb.E_MethodRule) {
		if ext, _ := proto.GetExtension(m.Options, rule_pb.E_MethodRule); ext != nil {
			if x, _ := ext.(*rule_pb.MethodRule); x != nil {
				method = x
			}
		}
	}
	inpDesc := p.ObjectNamed(m.GetInputType()).(*generator.Descriptor).DescriptorProto
	if inpDesc.Options != nil && proto.HasExtension(inpDesc.Options, rule_pb.E_MethodInputRule) {
		if ext, _ := proto.GetExtension(inpDesc.Options, rule_pb.E_MethodInputRule); ext != nil {
			if x, _ := ext.(*rule_pb.MethodInputRule); x != nil {
				input = x
			}
		}
	}
	return
}

func init() {
	generator.RegisterPlugin(new(qingcloudPlugin))
}
