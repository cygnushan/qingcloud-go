// Copyright 2017 <chaishushan{AT}gmail.com>. All rights reserved.
// Use of this source code is governed by a Apache
// license that can be found in the LICENSE file.

// Package qingcloud outputs qingcloud stub code.
package qingcloud

import (
	"bytes"
	"strings"
	"text/template"

	rule_pb "github.com/chai2010/qingcloud-go/spec.pb/qingcloud_sdk_rule"
	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	"github.com/golang/protobuf/protoc-gen-go/generator"
)

// qingcloudPlugin produce the Service interface.
type qingcloudPlugin struct {
	*generator.Generator
}

// Name returns the name of the plugin.
func (p *qingcloudPlugin) Name() string { return "qingcloud" }

// Init is called once after data structures are built but before
// code generation begins.
func (p *qingcloudPlugin) Init(g *generator.Generator) {
	p.Generator = g
}

// Generate produces the code generated by the plugin for this file.
func (p *qingcloudPlugin) GenerateImports(file *generator.FileDescriptor) {
	if len(file.Service) > 0 {
		p.P(GetImportsCode())
	}
}

// Generate generates the Service interface.
// rpc service can't handle other proto message!!!
func (p *qingcloudPlugin) Generate(file *generator.FileDescriptor) {
	if true {
		for _, svc := range file.Service {
			p.genServiceInterface(file, svc)
			p.genServiceServer(file, svc)
			p.genServiceClient(file, svc)
		}
		return
	}

	for _, v := range file.Service {
		p.P(p.buildServiceSpec(v).Code())
	}
	for _, v := range file.MessageType {
		p.P(p.buildMessageSpec(v).Code())
	}
}

func (p *qingcloudPlugin) buildServiceSpec(svc *descriptor.ServiceDescriptorProto) *ServiceSpec {
	spec := new(ServiceSpec)

	if rule := p.getServiceRule(svc); rule != nil {
		spec.DocUrl = rule.GetDocUrl()
		spec.ServiceName = rule.GetServiceName()
		spec.MainServiceName = rule.GetMainServiceName()
	} else {
		spec.ServiceName = generator.CamelCase(svc.GetName())
	}

	for _, m := range svc.Method {
		methodSpec := MethodSpec{
			MethodName: generator.CamelCase(m.GetName()),
		}

		if rule := p.getMethodRule(m); rule != nil {
			methodSpec.DocUrl = rule.GetDocUrl()
			methodSpec.HttpMethod = rule.GetHttpMethod()
			methodSpec.InputTypeName = rule.GetHttpMethod()
			methodSpec.OutputTypeName = rule.GetOutputType()
		}

		if methodSpec.InputTypeName == "" {
			methodSpec.InputTypeName = p.TypeName(p.ObjectNamed(m.GetInputType()))
		}
		if methodSpec.OutputTypeName == "" {
			methodSpec.OutputTypeName = p.TypeName(p.ObjectNamed(m.GetOutputType()))
		}
		if methodSpec.HttpMethod == "" {
			methodSpec.HttpMethod = "GET"
		}

		spec.MethodList = append(spec.MethodList, methodSpec)
	}

	return spec
}

func (p *qingcloudPlugin) buildMessageSpec(msg *descriptor.DescriptorProto) *MessageSpec {
	if rule := p.getMessageRule(msg); rule != nil {
		// TODO
	}
	return nil
}

func (p *qingcloudPlugin) genServiceInterface(
	file *generator.FileDescriptor,
	svc *descriptor.ServiceDescriptorProto,
) {
	const serviceInterfaceTmpl = `
type {{.ServiceName}}Interface interface {
	{{.CallMethodList}}
}
`
	const callMethodTmpl = `
{{.MethodName}}(in *{{.ArgsType}}) (out *{{.ReplyType}}, err error)`

	// gen call method list
	var callMethodList string
	for _, m := range svc.Method {
		out := bytes.NewBuffer([]byte{})
		t := template.Must(template.New("").Parse(callMethodTmpl))
		t.Execute(out, &struct{ ServiceName, MethodName, ArgsType, ReplyType string }{
			ServiceName: generator.CamelCase(svc.GetName()),
			MethodName:  generator.CamelCase(m.GetName()),
			ArgsType:    p.TypeName(p.ObjectNamed(m.GetInputType())),
			ReplyType:   p.TypeName(p.ObjectNamed(m.GetOutputType())),
		})
		callMethodList += out.String()

		p.RecordTypeUse(m.GetInputType())
		p.RecordTypeUse(m.GetOutputType())
	}

	// gen all interface code
	{
		out := bytes.NewBuffer([]byte{})
		t := template.Must(template.New("").Parse(serviceInterfaceTmpl))
		t.Execute(out, &struct{ ServiceName, CallMethodList string }{
			ServiceName:    generator.CamelCase(svc.GetName()),
			CallMethodList: callMethodList,
		})
		p.P(out.String())
	}
}

func (p *qingcloudPlugin) genServiceServer(
	file *generator.FileDescriptor,
	svc *descriptor.ServiceDescriptorProto,
) {
	const serviceHelperFunTmpl = `
{{/* TODO */}}
`
	{
		out := bytes.NewBuffer([]byte{})
		t := template.Must(template.New("").Parse(serviceHelperFunTmpl))
		t.Execute(out, &struct{ PackageName, ServiceName, ServiceRegisterName string }{
			PackageName:         file.GetPackage(),
			ServiceName:         generator.CamelCase(svc.GetName()),
			ServiceRegisterName: generator.CamelCase(svc.GetName()),
		})
		p.P(out.String())
	}
}

func (p *qingcloudPlugin) genServiceClient(
	file *generator.FileDescriptor,
	svc *descriptor.ServiceDescriptorProto,
) {
	const clientHelperFuncTmpl = `
type {{.ServiceName}} struct {
	Config           *config.Config
	Properties       *{{.ServiceName}}Properties
	LastResponseBody string
}

func New{{.ServiceName}}(conf *config.Config, zone string) (p *{{.ServiceName}}) {
	return &{{.ServiceName}}{
		Config:     conf,
		Properties: &{{.ServiceName}}Properties{Zone: zone},
	}
}

func (s *QingCloudService) {{.ServiceBaseName}}(zone string) (*{{.ServiceName}}, error) {
	properties := &{{.ServiceName}}Properties{
		Zone: zone,
	}

	return &{{.ServiceName}}{Config: s.Config, Properties: properties}, nil
}

{{.MethodList}}
`
	const clientMethodTmpl = `
func (p *{{.ServiceName}}) {{.MethodName}}(in *{{.ArgsType}}) (out *{{.ReplyType}}, err error) {
	if in == nil {
		in = &{{.ArgsType}}{}
	}
	o := &data.Operation{
		Config:        p.Config,
		Properties:    p.Properties,
		APIName:       "{{.MethodName}}",
		RequestMethod: "{{.RequestMethod}}", // GET or POST
	}

	x := &{{.ReplyType}}{}
	r, err := request.New(o, in, x)
	if err != nil {
		return nil, err
	}

	err = r.Send()
	p.LastResponseBody = o.ResponseBody

	if err != nil {
		return nil, err
	}

	return x, err
}

{{if .NeedValidate}}
func (p *{{.ArgsType}}) Validate() error {
	return nil
}
{{end}}
`

	// gen client method list
	var methodList string
	for _, m := range svc.Method {
		var RequestMethod = "GET" // default is GET

		methodRule := p.getMethodRule(m)
		if methodRule != nil {
			if kind := methodRule.GetHttpMethod(); kind != "" {
				RequestMethod = kind
			}
		}

		inputRule := p.getMessageRule(p.getMethodInputDescriptor(m))
		if inputRule != nil {
			//
		}

		out := bytes.NewBuffer([]byte{})
		t := template.Must(template.New("").Parse(clientMethodTmpl))
		t.Execute(out, &struct {
			ServiceName         string
			ServiceRegisterName string
			MethodName          string
			ArgsType            string
			ReplyType           string
			RequestMethod       string
			NeedValidate        bool
		}{
			ServiceName:         generator.CamelCase(svc.GetName()),
			ServiceRegisterName: generator.CamelCase(svc.GetName()),
			MethodName:          generator.CamelCase(m.GetName()),
			ArgsType:            p.TypeName(p.ObjectNamed(m.GetInputType())),
			ReplyType:           p.TypeName(p.ObjectNamed(m.GetOutputType())),
			RequestMethod:       RequestMethod,
			NeedValidate:        !strings.Contains(p.TypeName(p.ObjectNamed(m.GetOutputType())), "."),
		})
		methodList += out.String()
	}

	// gen all client code
	{
		out := bytes.NewBuffer([]byte{})
		t := template.Must(template.New("").Parse(clientHelperFuncTmpl))
		t.Execute(out, &struct {
			PackageName     string
			ServiceName     string
			ServiceBaseName string
			MethodList      string
		}{
			PackageName:     file.GetPackage(),
			ServiceName:     generator.CamelCase(svc.GetName()),
			ServiceBaseName: strings.TrimSuffix(generator.CamelCase(svc.GetName()), "Service"),
			MethodList:      methodList,
		})
		p.P(out.String())
	}
}

func (p *qingcloudPlugin) genMethodInputValidate(m *descriptor.MethodDescriptorProto) string {
	inputTypeName := p.TypeName(p.ObjectNamed(m.GetInputType()))
	if strings.Contains(inputTypeName, ".") {
		return ""
	}

	desc := p.ObjectNamed(m.GetInputType()).(*generator.Descriptor).DescriptorProto
	rule := p.getMessageRule(p.getMethodInputDescriptor(m))

	//	desc := p.ObjectNamed(m.GetInputType()).(*generator.Descriptor).DescriptorProto

	for i, field := range desc.Field {
		_ = field.Name
		_ = field.Type

		_ = i
		_ = field
	}

	_ = desc
	_ = rule

	return ""
}

func (p *qingcloudPlugin) getServiceRule(svc *descriptor.ServiceDescriptorProto) (svcRule *ServiceRule) {
	if svc.Options != nil && proto.HasExtension(svc.Options, rule_pb.E_ServiceRule) {
		if ext, _ := proto.GetExtension(svc.Options, rule_pb.E_ServiceRule); ext != nil {
			if x, _ := ext.(*rule_pb.ServiceOptionsRule); x != nil {
				svcRule = &ServiceRule{x}
			}
		}
	}
	return
}

func (p *qingcloudPlugin) getMethodRule(m *descriptor.MethodDescriptorProto) *MethodRule {
	if m.Options != nil && proto.HasExtension(m.Options, rule_pb.E_MethodRule) {
		if ext, _ := proto.GetExtension(m.Options, rule_pb.E_MethodRule); ext != nil {
			if x, _ := ext.(*rule_pb.MethodOptionsRule); x != nil {
				return &MethodRule{x}
			}
		}
	}
	return nil
}

func (p *qingcloudPlugin) getMessageRule(m *descriptor.DescriptorProto) *MessageRule {
	if m.Options != nil && proto.HasExtension(m.Options, rule_pb.E_MessageRule) {
		if ext, _ := proto.GetExtension(m.Options, rule_pb.E_MessageRule); ext != nil {
			if x, _ := ext.(*rule_pb.MessageOptionsRule); x != nil {
				return &MessageRule{x}
			}
		}
	}
	return nil
}

func (p *qingcloudPlugin) getMethodInputDescriptor(m *descriptor.MethodDescriptorProto) *descriptor.DescriptorProto {
	return p.ObjectNamed(m.GetInputType()).(*generator.Descriptor).DescriptorProto
}
func (p *qingcloudPlugin) getMethodOutputDescriptor(m *descriptor.MethodDescriptorProto) *descriptor.DescriptorProto {
	return p.ObjectNamed(m.GetOutputType()).(*generator.Descriptor).DescriptorProto
}

func init() {
	generator.RegisterPlugin(new(qingcloudPlugin))
}
