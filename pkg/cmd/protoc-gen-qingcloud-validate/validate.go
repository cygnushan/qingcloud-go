// Copyright 2017 <chaishushan{AT}gmail.com>. All rights reserved.
// Use of this source code is governed by a Apache
// license that can be found in the LICENSE file.

package qingcloud_plugin_validate

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"path"
	"strings"

	spec_metadata "github.com/chai2010/qingcloud-go/pkg/api/spec_metadata"
	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	"github.com/golang/protobuf/protoc-gen-go/generator"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
)

// validatePlugin produce the Validator method.
type validatePlugin struct {
	*generator.Generator
	ValidateGenerator
}

// Name returns the name of the plugin.
func (p *validatePlugin) Name() string { return "qingcloud-validate" }

// Init is called once after data structures are built but before
// code generation begins.
func (p *validatePlugin) Init(g *generator.Generator) {
	p.Generator = g
}

func (p *validatePlugin) InitValidateGenerator(g ValidateGenerator) {
	p.ValidateGenerator = g
}

// Generate produces the code generated by the plugin for this file.
func (p *validatePlugin) GenerateImports(file *generator.FileDescriptor) {
	// skip
}

// Generate generates the Service interface.
// rpc service can't handle other proto message!!!
func (p *validatePlugin) Generate(file *generator.FileDescriptor) {
	if !p.isFileNeedGenerate(file) {
		return
	}

	var buf bytes.Buffer
	fmt.Fprintln(&buf, p.HeaderCode(file))

	for _, msg := range file.MessageType {
		fmt.Fprintln(&buf, p.ValidateCode(file, msg))
	}

	fileContent := buf.String()
	if code, err := format.Source(buf.Bytes()); err != nil {
		log.Printf("validatePlugin.Generate: format %q failed, err = %v", file.GetName(), err)
	} else {
		fileContent = string(code)
	}

	p.Generator.Response.File = append(p.Generator.Response.File, &plugin.CodeGeneratorResponse_File{
		Name:    proto.String(p.goFileName(file)),
		Content: proto.String(fileContent),
	})
}

func (p *validatePlugin) isFileNeedGenerate(file *generator.FileDescriptor) bool {
	for _, v := range p.Generator.Request.FileToGenerate {
		if v == file.GetName() {
			return true
		}
	}
	return false
}

func (p *validatePlugin) goFileName(file *generator.FileDescriptor) string {
	name := *file.Name
	if ext := path.Ext(name); ext == ".proto" || ext == ".protodevel" {
		name = name[:len(name)-len(ext)]
	}
	name += p.FileNameExt()

	// Does the file have a "go_package" option?
	// If it does, it may override the filename.
	if impPath, _, ok := p.goPackageOption(file); ok && impPath != "" {
		// Replace the existing dirname with the declared import path.
		_, name = path.Split(name)
		name = path.Join(impPath, name)
		return name
	}

	return name
}

func (p *validatePlugin) goPackageOption(file *generator.FileDescriptor) (impPath, pkg string, ok bool) {
	pkg = file.GetOptions().GetGoPackage()
	if pkg == "" {
		return
	}
	ok = true
	// The presence of a slash implies there's an import path.
	slash := strings.LastIndex(pkg, "/")
	if slash < 0 {
		return
	}
	impPath, pkg = pkg, pkg[slash+1:]
	// A semicolon-delimited suffix overrides the package name.
	sc := strings.IndexByte(impPath, ';')
	if sc < 0 {
		return
	}
	impPath, pkg = impPath[:sc], impPath[sc+1:]
	return
}

func (p *validatePlugin) getMessageFieldOption(m *descriptor.FieldDescriptorProto) *spec_metadata.FieldOption {
	if m.Options != nil && proto.HasExtension(m.Options, spec_metadata.E_FieldOption) {
		if ext, _ := proto.GetExtension(m.Options, spec_metadata.E_FieldOption); ext != nil {
			if x, _ := ext.(*spec_metadata.FieldOption); x != nil {
				return x
			}
		}
	}
	return nil
}
